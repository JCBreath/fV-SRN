#include <catch.hpp>
#include <random>
#include <cuda_runtime.h>

#include <renderer_phase_function.cuh>
#include "test_utils.h"

namespace
{
	class TestSampler
	{
		std::default_random_engine rnd_;
		std::uniform_real_distribution<real_t> rd_;
		std::normal_distribution<real_t> nd_;
	public:
		TestSampler()
			: rnd_(42)
		{}

		real_t sampleUniform() { return rd_(rnd_); }
		real_t sampleNormal() { return nd_(rnd_); }
	};
}

TEST_CASE("PhaseFunction-Angles", "[math]")
{
	TestSampler sampler;
	int n = 100;
	int m = 100;

	for (int i=0; i<n; ++i)
	{
		real_t cosTheta = sampler.sampleUniform() * 2 - 1; //[-1,+1]
		real3 dirIn = normalize(make_real3(
			sampler.sampleUniform() * 2 - 1,
			sampler.sampleUniform() * 2 - 1,
			sampler.sampleUniform() * 2 - 1
		));
		real3 dirOut = kernel::PhaseFunctionHelpers::directionFromAngle(dirIn, cosTheta, sampler);
		INFO("dirIn=(" << -dirIn.x << ", " << -dirIn.y << ", " << -dirIn.z << ")");
		INFO("cosTheta=" << cosTheta);
		INFO("dirOut=(" << dirOut.x << ", " << dirOut.y << ", " << dirOut.z << ")");
		REQUIRE(lengthSquared(dirOut) == Approx(1.0));
		real_t cosTheta2 = kernel::PhaseFunctionHelpers::getCosAngle(dirIn, dirOut);
		REQUIRE(cosTheta == Approx(cosTheta2));
	}
}


template<typename PhaseFunction>
void testPhaseFunction()
{
	TestSampler sampler;
	PhaseFunction phase;

	static const real3 pos = make_real3(0);
	static const int batch = 0;
	static const int BINS = 128;
	static const real3 dirIn = make_real3(1, 0, 0);
	static const int SAMPLES1 = 1 << 15;
	static const int SAMPLES2 = 1 << 20;

	//1. Test that phase.prop is in [0,1] and integrates to one over the sphere.
	//Use fibonacci sphere to generate directions on the sphere
	Histogram histo1(-1, +1, BINS);
	static const double SCALE1 = 4 * M_PI / SAMPLES1;
	for (const real3& dirOut : fibonacciSphere<real_t>(SAMPLES1))
	{
		real_t cosTheta = kernel::PhaseFunctionHelpers::getCosAngle(dirIn, dirOut);
		real_t prob = phase.probAngle(cosTheta, pos, batch);
		REQUIRE(prob >= 0);
		histo1.inc(cosTheta, prob * SCALE1);
	}
	double sum1 = histo1.sum();
	CHECK(sum1 == Approx(1.0).epsilon(1e-4));

	//2. Test that the distribution of angles generated by sampleAngle
	//matches the probability function
	Histogram histo2(-1, +1, BINS);
	static const double SCALE2 = 1.0 / SAMPLES2;
	for (int i = 0; i < SAMPLES2; ++i)
	{
		real_t cosTheta = phase.sampleAngle(dirIn, pos, sampler, 0);
		real_t cosTheta2 = kernel::PhaseFunctionHelpers::getCosAngle(dirIn, 
			kernel::PhaseFunctionHelpers::directionFromAngle(dirIn, cosTheta, sampler));
		REQUIRE(cosTheta == Approx(cosTheta2).epsilon(1e-5));
		REQUIRE(cosTheta >= -1);
		REQUIRE(cosTheta <= 1);
		histo2.inc(cosTheta, SCALE2);
	}

	CHECK(distance(histo1, histo2) < 0.03);
}

TEST_CASE("PhaseFunction-HenyeyGreenstein", "[math]")
{
	static const std::vector<double> g = { -0.9, -0.5, 0, 0.5, 0.9 };
	for (size_t i=0; i<g.size(); ++i)
	{
		INFO("i=" << i << ", g=" << g[i]);
		phaseFunctionHenyeyGreensteinParameters.g = static_cast<real_t>(g[i]);
		testPhaseFunction<kernel::PhaseFunctionHenyeyGreenstein>();
	}
}

TEST_CASE("PhaseFunction-Rayleigh", "[math]")
{
	testPhaseFunction<kernel::PhaseFunctionRayleigh>();
}